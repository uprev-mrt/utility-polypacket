/**
  *@file SampleProtocol.cpp
  *@brief generated protocol source code
  *@author make_protocol.py
  *@date 03/18/19
  */

/***********************************************************
        THIS FILE IS AUTOGENERATED. DO NOT MODIFY
***********************************************************/

#include "SampleProtocol.h"
#include <assert.h>


//Define packet IDs
#define  SP_PACKET_ACK_ID 0
#define  SP_PACKET_SETDATA_ID 1
#define  SP_PACKET_GETDATA_ID 2
#define  SP_PACKET_RESPDATA_ID 3
#define  SP_PACKET_BLOCKREQ_ID 4
#define  SP_PACKET_BLOCKRESP_ID 5


//Global descriptors
poly_packet_desc_t* SP_PACKET_ACK;
poly_packet_desc_t* SP_PACKET_SETDATA;
poly_packet_desc_t* SP_PACKET_GETDATA;
poly_packet_desc_t* SP_PACKET_RESPDATA;
poly_packet_desc_t* SP_PACKET_BLOCKREQ;
poly_packet_desc_t* SP_PACKET_BLOCKRESP;

poly_field_desc_t* SP_FIELD_SRC;
poly_field_desc_t* SP_FIELD_DST;
poly_field_desc_t* SP_FIELD_CMD;
poly_field_desc_t* SP_FIELD_SENSORA;
poly_field_desc_t* SP_FIELD_SENSORB;
poly_field_desc_t* SP_FIELD_SENSORNAME;
poly_field_desc_t* SP_FIELD_BLOCKOFFSET;
poly_field_desc_t* SP_FIELD_BLOCKSIZE;
poly_field_desc_t* SP_FIELD_BLOCKDATA;

static poly_service_t SP_SERVICE;

/*******************************************************************************
  Service Functions
*******************************************************************************/

/**
  *@brief initializes sp_protocol
  *@param interfaceCount number of interfaces to create
  */
void sp_service_init(int interfaceCount)
{
  //initialize core service
  poly_service_init(&SP_SERVICE,6, interfaceCount);

  //Build Packet Descriptors
  SP_PACKET_ACK = new_poly_packet_desc("ack", 0);
  SP_PACKET_SETDATA = new_poly_packet_desc("SetData", 5);
  SP_PACKET_GETDATA = new_poly_packet_desc("GetData", 5);
  SP_PACKET_RESPDATA = new_poly_packet_desc("RespData", 5);
  SP_PACKET_BLOCKREQ = new_poly_packet_desc("blockReq", 4);
  SP_PACKET_BLOCKRESP = new_poly_packet_desc("blockResp", 5);

  //Build Field Descriptors
  SP_FIELD_SRC = new_poly_field_desc("src", TYPE_UINT16, 1, FORMAT_HEX);
  SP_FIELD_DST = new_poly_field_desc("dst", TYPE_UINT16, 1, FORMAT_HEX);
  SP_FIELD_CMD = new_poly_field_desc("cmd", TYPE_UINT8, 1, FORMAT_HEX);
  SP_FIELD_SENSORA = new_poly_field_desc("sensorA", TYPE_INT16, 1, FORMAT_DEC);
  SP_FIELD_SENSORB = new_poly_field_desc("sensorB", TYPE_INT, 1, FORMAT_DEC);
  SP_FIELD_SENSORNAME = new_poly_field_desc("sensorName", TYPE_STRING, 32, FORMAT_ASCII);
  SP_FIELD_BLOCKOFFSET = new_poly_field_desc("blockOffset", TYPE_UINT32, 1, FORMAT_HEX);
  SP_FIELD_BLOCKSIZE = new_poly_field_desc("blockSize", TYPE_UINT32, 1, FORMAT_DEC);
  SP_FIELD_BLOCKDATA = new_poly_field_desc("blockData", TYPE_UINT8, 64, FORMAT_NONE);


  //Setting Field Descriptors for SetData
  poly_packet_desc_add_field(SP_PACKET_SETDATA , SP_FIELD_SRC , true );
  poly_packet_desc_add_field(SP_PACKET_SETDATA , SP_FIELD_DST , true );
  poly_packet_desc_add_field(SP_PACKET_SETDATA , SP_FIELD_SENSORA , false );
  poly_packet_desc_add_field(SP_PACKET_SETDATA , SP_FIELD_SENSORB , false );
  poly_packet_desc_add_field(SP_PACKET_SETDATA , SP_FIELD_SENSORNAME , false );

  //Setting Field Descriptors for GetData
  poly_packet_desc_add_field(SP_PACKET_GETDATA , SP_FIELD_SRC , true );
  poly_packet_desc_add_field(SP_PACKET_GETDATA , SP_FIELD_DST , true );
  poly_packet_desc_add_field(SP_PACKET_GETDATA , SP_FIELD_SENSORA , false );
  poly_packet_desc_add_field(SP_PACKET_GETDATA , SP_FIELD_SENSORB , false );
  poly_packet_desc_add_field(SP_PACKET_GETDATA , SP_FIELD_SENSORNAME , false );

  //Setting Field Descriptors for RespData
  poly_packet_desc_add_field(SP_PACKET_RESPDATA , SP_FIELD_SRC , true );
  poly_packet_desc_add_field(SP_PACKET_RESPDATA , SP_FIELD_DST , true );
  poly_packet_desc_add_field(SP_PACKET_RESPDATA , SP_FIELD_SENSORA , false );
  poly_packet_desc_add_field(SP_PACKET_RESPDATA , SP_FIELD_SENSORB , false );
  poly_packet_desc_add_field(SP_PACKET_RESPDATA , SP_FIELD_SENSORNAME , false );

  //Setting Field Descriptors for blockReq
  poly_packet_desc_add_field(SP_PACKET_BLOCKREQ , SP_FIELD_SRC , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKREQ , SP_FIELD_DST , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKREQ , SP_FIELD_BLOCKOFFSET , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKREQ , SP_FIELD_BLOCKSIZE , true );

  //Setting Field Descriptors for blockResp
  poly_packet_desc_add_field(SP_PACKET_BLOCKRESP , SP_FIELD_SRC , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKRESP , SP_FIELD_DST , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKRESP , SP_FIELD_BLOCKOFFSET , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKRESP , SP_FIELD_BLOCKSIZE , true );
  poly_packet_desc_add_field(SP_PACKET_BLOCKRESP , SP_FIELD_BLOCKDATA , true );


  //Register packet descriptors with the service
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_ACK);
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_SETDATA);
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_GETDATA);
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_RESPDATA);
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_BLOCKREQ);
  poly_service_register_desc(&SP_SERVICE, SP_PACKET_BLOCKRESP);

  poly_service_start(&SP_SERVICE, 512);

}


/**
  *@brief attempts to process data in buffers and parse out packets
  */
void sp_service_process()
{
  static sp_packet_t packet;
  static sp_packet_t response;

  HandlerStatus_e status = PACKET_NOT_HANDLED;

  if(poly_service_try_parse(&SP_SERVICE, &packet.mPacket) == PACKET_VALID)
  {

    //set response token with ack flag (this will persist even when packet it built)
    response.mPacket.mHeader.mToken = packet.mPacket.mHeader.mToken | POLY_ACK_FLAG;

    //Dispatch packet
    switch(packet.mPacket.mDesc->mTypeId)
    {
      case SP_PACKET_ACK_ID:
        status = sp_ack_handler(&packet);
        break;
      case SP_PACKET_SETDATA_ID:
       poly_packet_build(&response.mPacket, SP_PACKET_RESPDATA,true);
       status = sp_setdata_handler(&packet , &response );
        break;
      case SP_PACKET_GETDATA_ID:
       poly_packet_build(&response.mPacket, SP_PACKET_RESPDATA,true);
       status = sp_getdata_handler(&packet , &response );
        break;
      case SP_PACKET_RESPDATA_ID:
        status = sp_respdata_handler(&packet);
        break;
      case SP_PACKET_BLOCKREQ_ID:
       poly_packet_build(&response.mPacket, SP_PACKET_BLOCKRESP,true);
       status = sp_blockreq_handler(&packet , &response );
        break;
      case SP_PACKET_BLOCKRESP_ID:
        status = sp_blockresp_handler(&packet);
        break;
      default:
        //we should never get here
        assert(false);
        break;
    }

    //If this packet doe not have an explicit response and AutoAck is enabled, create an ack packet
    if(( SP_SERVICE.mAutoAck ) && (!response.mPacket.mBuilt))
    {
      poly_packet_build(&response.mPacket, SP_PACKET_ACK,true);
    }

    //If the packet was not handled, throw it to the default handler
    if(status == PACKET_NOT_HANDLED)
    {
      status = sp_default_handler(&packet);
    }


    //If a response has been build and the status was not set to ignore, we send a response on the intrface it came from
    if(( status == PACKET_HANDLED) && (response.mPacket.mBuilt) )
    {
      poly_service_send(&SP_SERVICE, packet.mPacket.mInterface , &response.mPacket);
    }

    //Clean the packets
    poly_packet_clean(&packet.mPacket);
    poly_packet_clean(&response.mPacket);
  }

}


void sp_service_register_tx( int iface, poly_tx_callback txCallBack)
{
  poly_service_register_tx_callback(&SP_SERVICE, iface,txCallBack);
}

void sp_service_feed(int iface, uint8_t* data, int len)
{
  poly_service_feed(&SP_SERVICE,iface,data,len);
}

HandlerStatus_e sp_send(int iface, sp_packet_t* metaPacket)
{
  return poly_service_send(&SP_SERVICE, iface, &metaPacket->mPacket);
}

void sp_auto_ack(bool enable)
{
  SP_SERVICE.mAutoAck = enable;
}


/*******************************************************************************
  Meta packet
*******************************************************************************/

/**
  *@brief creates a new meta packet and returns a pointer to it
  *@param desc packet descriptor
  *@post creator is responsible for destroying with sp_packet_destroy()
  *@return ptr to new meta packet
  */
sp_packet_t* new_sp_packet(poly_packet_desc_t* desc)
{
  sp_packet_t* newMetaPacket = (sp_packet_t*) malloc(sizeof(sp_packet_t));

  //create new unallocated packet
  poly_packet_build(&newMetaPacket->mPacket, desc, true);

  return newMetaPacket;
}


/**
  *@brief frees memory allocated for metapacket
  *@param "metaPacket ptr to metaPacket
  */
void sp_destroy(sp_packet_t* metaPacket)
{
  //free internal poly_packet_t
  poly_packet_clean(&metaPacket->mPacket);

  //free memory
  free(metaPacket);
}

/*******************************************************************************

  Meta-Packet setters

*******************************************************************************/

void sp_setSrc(sp_packet_t* packet, uint16_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SRC);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setDst(sp_packet_t* packet, uint16_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_DST);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setCmd(sp_packet_t* packet, uint8_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_CMD);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setSensora(sp_packet_t* packet, int16_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORA);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setSensorb(sp_packet_t* packet, int val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORB);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setSensorname(sp_packet_t* packet, const char* val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORNAME);
  poly_field_set(field,( const uint8_t*) val);
}

void sp_setBlockoffset(sp_packet_t* packet, uint32_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKOFFSET);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setBlocksize(sp_packet_t* packet, uint32_t val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKSIZE);
  poly_field_set(field,( const uint8_t*) &val);
}

void sp_setBlockdata(sp_packet_t* packet, const uint8_t* val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKDATA);
  poly_field_set(field,( const uint8_t*) val);
}


/*******************************************************************************
  Meta-Packet getters
*******************************************************************************/

uint16_t sp_getSrc(sp_packet_t* packet)
{
  uint16_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SRC);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

uint16_t sp_getDst(sp_packet_t* packet)
{
  uint16_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_DST);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

uint8_t sp_getCmd(sp_packet_t* packet)
{
  uint8_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_CMD);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

int16_t sp_getSensora(sp_packet_t* packet)
{
  int16_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORA);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

int sp_getSensorb(sp_packet_t* packet)
{
  int val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORB);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

char* sp_getSensorname(sp_packet_t* packet)
{
  char* val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_SENSORNAME);
  val = (char*)poly_field_get(field, (uint8_t*)val);
  return val;
}

uint32_t sp_getBlockoffset(sp_packet_t* packet)
{
  uint32_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKOFFSET);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

uint32_t sp_getBlocksize(sp_packet_t* packet)
{
  uint32_t val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKSIZE);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}

uint8_t* sp_getBlockdata(sp_packet_t* packet)
{
  uint8_t* val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, SP_FIELD_BLOCKDATA);
  val = (uint8_t*)poly_field_get(field, (uint8_t*)val);
  return val;
}



/*******************************************************************************
  Weak packet handlers

  Do not modify these, just create your own without the '__weak' attribute
*******************************************************************************/
/**
  *@brief Handler for receiving ack packets
  *@param packet ptr to ack_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_ack_handler(sp_packet_t* ack)
{

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_ack_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving setdata packets
  *@param packet ptr to setdata_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_setdata_handler(sp_packet_t* SetData, sp_packet_t* RespData)
{
  //Set required Fields
  //sp_setsrc( value );                      //Set src value
  //sp_setdst( value );                      //Set dst value

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_setdata_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving getdata packets
  *@param packet ptr to getdata_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_getdata_handler(sp_packet_t* GetData, sp_packet_t* RespData)
{
  //Set required Fields
  //sp_setsrc( value );                      //Set src value
  //sp_setdst( value );                      //Set dst value

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_getdata_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving respdata packets
  *@param packet ptr to respdata_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_respdata_handler(sp_packet_t* RespData)
{

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_respdata_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving blockreq packets
  *@param packet ptr to blockreq_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_blockreq_handler(sp_packet_t* blockReq, sp_packet_t* blockResp)
{
  //Set required Fields
  //sp_setsrc( value );                      //Set src value
  //sp_setdst( value );                      //Set dst value
  //sp_setblockOffset( value );                      //Set blockOffset value
  //sp_setblockSize( value );                      //Set blockSize value
  //sp_setblockData( value );                      //Set blockData value

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_blockreq_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving blockresp packets
  *@param packet ptr to blockresp_packet_t  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_blockresp_handler(sp_packet_t* blockResp)
{

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_blockresp_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}



/**
  *@brief catch-all handler for any packet not handled by its default handler
  *@param metaPacket ptr to sp_packet_t containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e sp_default_handler( sp_packet_t * metaPacket)
{

  /* NOTE : This function should not be modified, when the callback is needed,
          sp_default_handler  should be implemented in the user file
  */
  
  return PACKET_NOT_HANDLED;
}