/**
  *@file MinimalService.c
  *@brief generated code for Minimal packet service
  *@author make_protocol.py
  *@date 03/24/19
  */

/***********************************************************
        THIS FILE IS AUTOGENERATED. DO NOT MODIFY
***********************************************************/

#include "MinimalService.h"
#include <assert.h>

#if defined(POLY_PACKET_DEBUG_LVL)
extern char POLY_DEBUG_PRINTBUF[512];
#endif

//Define packet IDs
#define  PP_PACKET_ACK_ID 0
#define  PP_PACKET_AMBIENTDATA_ID 1
#define  PP_PACKET_REQUESTAMBIENT_ID 2


//Global descriptors
poly_packet_desc_t* PP_PACKET_ACK;
poly_packet_desc_t* PP_PACKET_AMBIENTDATA;
poly_packet_desc_t* PP_PACKET_REQUESTAMBIENT;

poly_field_desc_t* PP_FIELD_AMBIENT;

//Global descriptors
poly_packet_desc_t _PP_PACKET_ACK;
poly_packet_desc_t _PP_PACKET_AMBIENTDATA;
poly_packet_desc_t _PP_PACKET_REQUESTAMBIENT;

poly_field_desc_t _PP_FIELD_AMBIENT;

static poly_service_t PP_SERVICE;

/*******************************************************************************
  Service Functions
*******************************************************************************/

/**
  *@brief initializes pp_protocol
  *@param interfaceCount number of interfaces to create
  */
void pp_service_init(int interfaceCount)
{
  //initialize core service
  poly_service_init(&PP_SERVICE,3, interfaceCount);

  //Build Packet Descriptors
  PP_PACKET_ACK = poly_packet_desc_init(&_PP_PACKET_ACK ,"ack", 0);
  PP_PACKET_AMBIENTDATA = poly_packet_desc_init(&_PP_PACKET_AMBIENTDATA ,"AmbientData", 1);
  PP_PACKET_REQUESTAMBIENT = poly_packet_desc_init(&_PP_PACKET_REQUESTAMBIENT ,"RequestAmbient", 0);

  //Build Field Descriptors
  PP_FIELD_AMBIENT = poly_field_desc_init( &_PP_FIELD_AMBIENT ,"ambient", TYPE_INT, 1, FORMAT_DEFAULT);


  //Setting Field Descriptors for AmbientData
  poly_packet_desc_add_field(PP_PACKET_AMBIENTDATA , PP_FIELD_AMBIENT , true );



  //Register packet descriptors with the service
  poly_service_register_desc(&PP_SERVICE, PP_PACKET_ACK);
  poly_service_register_desc(&PP_SERVICE, PP_PACKET_AMBIENTDATA);
  poly_service_register_desc(&PP_SERVICE, PP_PACKET_REQUESTAMBIENT);

  poly_service_start(&PP_SERVICE, 512);

}


void pp_service_teardown()
{
  //deinit Packet Descriptors
  PP_PACKET_ACK = poly_packet_desc_deinit(&_PP_PACKET_ACK);
  PP_PACKET_AMBIENTDATA = poly_packet_desc_deinit(&_PP_PACKET_AMBIENTDATA);
  PP_PACKET_REQUESTAMBIENT = poly_packet_desc_deinit(&_PP_PACKET_REQUESTAMBIENT);

  //deinitialize core service
  poly_service_deinit(&PP_SERVICE);

}

/**
  *@brief attempts to process data in buffers and parse out packets
  */
void pp_service_process()
{
  static pp_packet_t packet;
  static pp_packet_t response;

  HandlerStatus_e status = PACKET_NOT_HANDLED;

  //reset states of static packets
  packet.mBuilt = false;
  packet.mSpooled = false;
  response.mSpooled = false;
  response.mBuilt = false;

  if(poly_service_try_parse(&PP_SERVICE, &packet.mPacket) == PACKET_VALID)
  {
    //if we get here, then the inner packet was built by the parser
    packet.mBuilt = true;

    //set response token with ack flag (this will persist even when packet it built)
    response.mPacket.mHeader.mToken = packet.mPacket.mHeader.mToken | POLY_ACK_FLAG;

  #if defined(POLY_PACKET_DEBUG_LVL) && POLY_PACKET_DEBUG_LVL >0
    //If debug is enabled, print json of outgoing packets
    #if POLY_PACKET_DEBUG_LVL == 1
    poly_packet_print_json(&packet.mPacket, POLY_DEBUG_PRINTBUF, false );
    printf("  IN <<< %s\n\n",POLY_DEBUG_PRINTBUF );
    #elif POLY_PACKET_DEBUG_LVL > 1
    poly_packet_print_json(&packet.mPacket, POLY_DEBUG_PRINTBUF, true );
    printf("  IN <<< %s\n\n",POLY_DEBUG_PRINTBUF);
    #endif
    #if POLY_PACKET_DEBUG_LVL > 2
    poly_packet_print_packed(&packet.mPacket, POLY_DEBUG_PRINTBUF);
    printf("  IN <<< %s\n\n", POLY_DEBUG_PRINTBUF );
    #endif
  #endif

    //Dispatch packet
    switch(packet.mPacket.mDesc->mTypeId)
    {
      case PP_PACKET_ACK_ID:
        status = pp_ack_handler(&packet);
        break;
      case PP_PACKET_AMBIENTDATA_ID:
        status = pp_AmbientData_handler(&packet);
        break;
      case PP_PACKET_REQUESTAMBIENT_ID:
       pp_packet_build(&response, PP_PACKET_AMBIENTDATA);
       status = pp_RequestAmbient_handler(&packet , &response );
        break;
      default:
        //we should never get here
        assert(false);
        break;
    }

    //If this packet doe not have an explicit response and AutoAck is enabled, create an ack packet
    if(( PP_SERVICE.mAutoAck ) && (!response.mPacket.mBuilt))
    {
      pp_packet_build(&response, PP_PACKET_ACK);
    }

    //If the packet was not handled, throw it to the default handler
    if(status == PACKET_NOT_HANDLED)
    {
      status = pp_default_handler(&packet);
    }


    //If a response has been build and the status was not set to ignore, we send a response on the intrface it came from
    if(( status == PACKET_HANDLED) && (response.mPacket.mBuilt) )
    {
      pp_send(packet.mPacket.mInterface , &response);
    }

    //Clean the packets
    pp_clean(&packet);
    pp_clean(&response);
  }

  //despool any packets ready to go out
  poly_service_despool(&PP_SERVICE);

}


void pp_service_register_tx( int iface, poly_tx_callback txCallBack)
{
  poly_service_register_tx_callback(&PP_SERVICE, iface,txCallBack);
}

void pp_service_feed(int iface, uint8_t* data, int len)
{
  poly_service_feed(&PP_SERVICE,iface,data,len);
}

HandlerStatus_e pp_send(int iface, pp_packet_t* packet)
{
  HandlerStatus_e status;

  status = poly_service_spool(&PP_SERVICE, iface, &packet->mPacket);

  if(status == PACKET_SPOOLED)
  {
    packet->mSpooled = true;
  }

  return status;
}

void pp_auto_ack(bool enable)
{
  PP_SERVICE.mAutoAck = enable;
}


/*******************************************************************************
  Meta packet
*******************************************************************************/

/**
  *@brief initializes a new {proto.prefix}_packet_t
  *@param desc ptr to packet descriptor to model packet from
  */
void pp_packet_build(pp_packet_t* packet, poly_packet_desc_t* desc)
{
  //create new allocated packet
  poly_packet_build(&packet->mPacket, desc, true);
  packet->mBuilt = true;
  packet->mSpooled = false;
}


/**
  *@brief frees memory allocated for metapacket
  *@param packet ptr to metaPacket
  *
  */
void pp_clean(pp_packet_t* packet)
{
  //If the packet has been spooled, the spool is responsible for it now
  if(packet->mBuilt && (!packet->mSpooled))
  {
    poly_packet_clean(&packet->mPacket);
  }

}

int pp_fieldLen(pp_packet_t* packet, poly_field_desc_t* fieldDesc )
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, PP_FIELD_AMBIENT);
  return (int)field->mSize;
}

/*******************************************************************************

  Meta-Packet setters

*******************************************************************************/

/**
  *@brief Sets value of ambient field
  *@param packet ptr to pp_packet
  *@param val int to set field to
  */
void pp_setAmbient(pp_packet_t* packet, int val)
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, PP_FIELD_AMBIENT);
  poly_field_set(field,( const uint8_t*) &val);
}


/*******************************************************************************
  Meta-Packet getters
*******************************************************************************/

/**
  *@brief Gets value of ambient field
  *@param packet ptr to pp_packet
  *@return int data from field
  */
int pp_getAmbient(pp_packet_t* packet)
{
  int val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, PP_FIELD_AMBIENT);
  poly_field_get(field,(uint8_t*) &val);
  return val;
}


/*******************************************************************************
  Quick send functions
*******************************************************************************/

/**
  *@brief sends ack packet
  *@param iface indec of interface to send packet to
  *@return status send attempt
  */
HandlerStatus_e pp_sendAck(int iface)
{
  HandlerStatus_e status;
  //create packet
  pp_packet_t packet;
  pp_packet_build(&packet,PP_PACKET_ACK);

  //set fields

  status = pp_send(iface,&packet); //send packet
  pp_clean(&packet); //This will only free the underlying packet if the spooling was unsuccessful
  return status;
}

/**
  *@brief sends AmbientData packet
  *@param iface indec of interface to send packet to
  *@param ambient value to set ambient field to
  *@return status send attempt
  */
HandlerStatus_e pp_sendAmbientData(int iface, int ambient)
{
  HandlerStatus_e status;
  //create packet
  pp_packet_t packet;
  pp_packet_build(&packet,PP_PACKET_AMBIENTDATA);

  //set fields
  pp_setAmbient(&packet, ambient);

  status = pp_send(iface,&packet); //send packet
  pp_clean(&packet); //This will only free the underlying packet if the spooling was unsuccessful
  return status;
}

/**
  *@brief sends RequestAmbient packet
  *@param iface indec of interface to send packet to
  *@return status send attempt
  */
HandlerStatus_e pp_sendRequestAmbient(int iface)
{
  HandlerStatus_e status;
  //create packet
  pp_packet_t packet;
  pp_packet_build(&packet,PP_PACKET_REQUESTAMBIENT);

  //set fields

  status = pp_send(iface,&packet); //send packet
  pp_clean(&packet); //This will only free the underlying packet if the spooling was unsuccessful
  return status;
}



/*******************************************************************************
  Weak packet handlers

  Do not modify these, just create your own without the '__weak' attribute
*******************************************************************************/
/**
  *@brief Handler for receiving ack packets
  *@param ack incoming ack packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e pp_ack_handler(pp_packet_t* pp_ack)
{
  /*  Get Required Fields in packet */


  /* NOTE : This function should not be modified! If needed,  It should be overridden in the application code */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving AmbientData packets
  *@param AmbientData incoming AmbientData packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e pp_AmbientData_handler(pp_packet_t* pp_AmbientData)
{
  /*  Get Required Fields in packet */
  //int ambient = pp_getAmbient(pp_AmbientData);


  /* NOTE : This function should not be modified! If needed,  It should be overridden in the application code */

  return PACKET_NOT_HANDLED;
}


/**
  *@brief Handler for receiving RequestAmbient packets
  *@param RequestAmbient incoming RequestAmbient packet
  *@param AmbientData AmbientData packet to respond with
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e pp_RequestAmbient_handler(pp_packet_t* pp_RequestAmbient, pp_packet_t* pp_AmbientData)
{
  /*  Get Required Fields in packet */
  /*    Set required Fields in response  */
  //pp_setAmbient(pp_AmbientData, value );                   //Set ambient value


  /* NOTE : This function should not be modified! If needed,  It should be overridden in the application code */

  return PACKET_NOT_HANDLED;
}



/**
  *@brief catch-all handler for any packet not handled by its default handler
  *@param metaPacket ptr to pp_packet_t containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e pp_default_handler( pp_packet_t * pp_packet)
{

  /* NOTE : This function should not be modified, when the callback is needed,
          pp_default_handler  should be implemented in the user file
  */

  return PACKET_NOT_HANDLED;
}