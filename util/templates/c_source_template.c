/**
  *@file ${proto.fileName}.cpp
  *@brief generated protocol source code
  *@author make_protocol.py
  *@date 03/18/19
  */

/***********************************************************
        THIS FILE IS AUTOGENERATED. DO NOT MODIFY
***********************************************************/

#include "${proto.fileName}.h"
#include <assert.h>


//Define packet IDs
% for packet in proto.packets:
#define ${} ${packet.globalName}_ID ${packet.packetId}
% endfor


//Global descriptors
% for packet in proto.packets:
poly_packet_desc_t* ${packet.globalName};
% endfor

% for field in proto.fields:
poly_field_desc_t* ${field.globalName};
% endfor

poly_service_t* ${proto.service()};

/*******************************************************************************
  Service Process
*******************************************************************************/
/**
  *@brief attempts to process data in buffers and parse out packets
  */
void ${proto.prefix}_service_process()
{
  static ${proto.prefix}_packet_t metaPacket;
  metaPacket.pPacket = &metaPacket.mPacket;

  HandlerStatus_e status = PACKET_UNHANDLED;

  if(poly_service_try_parse(${proto.service()}, &metaPacket.mPacket) == PACKET_VALID)
  {

    //Dispatch packet
    switch(metaPacket.mPacket.mDesc->mTypeId)
    {
  % for packet in proto.packets:
      case ${packet.globalName}_ID:
        metaPacket.mPayload.${packet.name.lower()} = (${packet.structName}*) malloc(sizeof(${packet.structName}));
        ${proto.prefix}_${packet.name.lower()}_bind(metaPacket.mPayload.${packet.name.lower()}, &metaPacket.mPacket, true);
        status = ${proto.prefix}_${packet.name.lower()}_handler(metaPacket.mPayload.${packet.name.lower()});
        break;
  % endfor
      default:
        //we should never get here
        assert(false);
        break;
    }

    //If the packet was not handled, throw it to the default handler
    if(status == PACKET_UNHANDLED)
      status = ${proto.prefix}_default_handler(&metaPacket);

    ${proto.prefix}_teardown(&metaPacket);
  }

}

void ${proto.prefix}_service_register_tx( int iface, poly_tx_callback txCallBack)
{
  poly_service_register_tx_callback(${proto.service()}, iface,txCallBack);
}

/*******************************************************************************
  Service initializer
*******************************************************************************/

/**
  *@brief initializes ${proto.prefix}_protocol
  *@param interfaceCount number of interfaces to create
  */
void ${proto.prefix}_service_init(int interfaceCount)
{

  ${proto.service()} = new_poly_service(${len(proto.packets)}, interfaceCount);

  //Build Packet Descriptors
% for packet in proto.packets:
  ${packet.globalName} = new_poly_packet_desc("${packet.name}", ${len(packet.fields)});
% endfor

  //Build Field Descriptors
% for field in proto.fields:
  ${field.globalName} = new_poly_field_desc("${field.name}", TYPE_${field.type.upper()}, ${field.arrayLen}, ${field.format.upper()});
% endfor

% for packet in proto.packets:
  //Settomg Field Descriptors for ${packet.name}
  % for field in packet.fields:
  poly_packet_desc_add_field(${packet.globalName} , ${field.globalName} , ${str(field.isRequired).lower()} );
  % endfor
% endfor

  //Register packet descriptors with the service
% for packet in proto.packets:
  poly_service_register_desc(${proto.service()}, ${packet.globalName});
% endfor

  poly_service_start(${proto.service()}, 512);

}

void ${proto.prefix}_service_feed(int iface, uint8_t* data, int len)
{
  poly_service_feed(${proto.service()},iface,data,len);
}

HandlerStatus_e ${proto.prefix}_service_send(int iface, poly_packet_t* packet)
{
  return poly_service_send(${proto.service()}, iface, packet);
}

/*******************************************************************************
  Meta packet
*******************************************************************************/

/**
  *@brief creates a new meta packet and returns a pointer to it
  *@param desc packet descriptor
  *@post creator is responsible for destroying with ${proto.prefix}_packet_destroy()
  *@return ptr to new meta packet
  */
${proto.prefix}_packet_t* new_${proto.prefix}_packet(poly_packet_desc_t* desc)
{
  ${proto.prefix}_packet_t* newMetaPacket = (${proto.prefix}_packet_t*) malloc(sizeof(${proto.prefix}_packet_t));

  //create new unallocated packet
  poly_packet_init(&newMetaPacket->mPacket, desc, false);
  newMetaPacket->pPacket = &newMetaPacket->mPacket;

  switch(newMetaPacket->mPacket.mDesc->mTypeId)
  {
% for packet in proto.packets:
    case ${packet.globalName}_ID:
      newMetaPacket->mPayload.${packet.name.lower()} = (${packet.structName}*) malloc(sizeof(${packet.structName}));
      ${proto.prefix}_${packet.name.lower()}_bind(newMetaPacket->mPayload.${packet.name.lower()}, &newMetaPacket->mPacket, false);
      break;
% endfor
  }

  return newMetaPacket;
}

/**
  *@brief reset mega packet to a default state by freeing memory of payload
  *@param "metaPacket ptr to metaPacket
  */
void ${proto.prefix}_teardown(${proto.prefix}_packet_t* metaPacket)
{
  switch(metaPacket->mPacket.mDesc->mTypeId)
  {
% for packet in proto.packets:
    case ${packet.globalName}_ID:
    free(metaPacket->mPayload.${packet.name.lower()});
    break;
% endfor
  }

  poly_packet_destroy(&metaPacket->mPacket);
}

/**
  *@brief frees memory allocated for metapacket
  *@param "metaPacket ptr to metaPacket
  */
void ${proto.prefix}_destroy(${proto.prefix}_packet_t* metaPacket)
{
  //teardown
  ${proto.prefix}_teardown(metaPacket);

  //free memory
  free(metaPacket);
}

/*******************************************************************************

  Meta-Packet setters

*******************************************************************************/

% for field in proto.fields:
%if field.isArray:
void ${proto.prefix}_set${field.name.capitalize()}(${proto.prefix}_packet_t* packet, const ${field.getParamType()} val)
% else:
void ${proto.prefix}_set${field.name.capitalize()}(${proto.prefix}_packet_t* packet, ${field.getParamType()} val)
%endif
{
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, ${field.globalName});
%if field.isArray:
  poly_field_set(field,( const uint8_t*) val);
% else:
  poly_field_set(field,( const uint8_t*) &val);
% endif
}

% endfor

/*******************************************************************************
  Meta-Packet getters
*******************************************************************************/

% for field in proto.fields:
${field.getParamType()} ${proto.prefix}_get${field.name.capitalize()}(${proto.prefix}_packet_t* packet)
{
  ${field.getParamType()} val;
  poly_field_t* field = poly_packet_get_field(&packet->mPacket, ${field.globalName});
%if field.isArray:
  val = (${field.getParamType()})poly_field_get(field, (uint8_t*)val);
% else:
  poly_field_get(field,(uint8_t*) &val);
% endif
  return val;
}

% endfor


/*******************************************************************************
  Packet binders
*******************************************************************************/
% for packet in proto.packets:
/**
  *@brief Binds struct to poly_service_t
  *@param ${packet.name.lower()} ptr to ${packet.structName} to be bound
  *@param packet packet to bind to
  */
void ${proto.prefix}_${packet.name.lower()}_bind(${packet.structName}* ${packet.name.lower()}, poly_packet_t* packet, bool copy)
{
  ${packet.name.lower()}->pPacket = packet;

% for field in packet.fields:
  poly_field_bind( poly_packet_get_field(packet, ${field.globalName}), (uint8_t*) &${packet.name.lower()}->${field.memberName}, copy);
% endfor

}

% endfor

/*******************************************************************************
  Weak packet handlers

  Do not modify these, just create your own without the '__weak' attribute
*******************************************************************************/
% for packet in proto.packets:
/**
  *@brief Handler for receiving ${packet.name.lower()} packets
  *@param packet ptr to ${packet.structName}  containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e ${proto.prefix}_${packet.name.lower()}_handler(${packet.structName} * packet)
{
  /* NOTE : This function should not be modified, when the callback is needed,
          ${proto.prefix}_${packet.name.lower()}_handler  should be implemented in the user file
  */
  return PACKET_UNHANDLED;
}
% endfor

/**
  *@brief catch-all handler for any packet not handled by its default handler
  *@param metaPacket ptr to ${proto.prefix}_packet_t containing packet
  *@return handling status
  */
__attribute__((weak)) HandlerStatus_e ${proto.prefix}_default_handler( ${proto.prefix}_packet_t * metaPacket)
{
  /* NOTE : This function should not be modified, when the callback is needed,
          ${proto.prefix}_default_handler  should be implemented in the user file
  */
  return PACKET_UNHANDLED;
}
