/**
  *@file ${proto.fileName}.h
  *@brief generated protocol source code
  *@author make_protocol.py
  *@date 03/18/19
  */

/***********************************************************
        THIS FILE IS AUTOGENERATED. DO NOT MODIFY
***********************************************************/
#include "Utilities/PolyPacket/poly_service.h"


% for field in proto.fields:
% if field.isEnum:
/* Enums for ${field.name} field */
typedef enum{
  % for val in field.vals:
  ${proto.prefix.upper()+"_"+field.name.upper() + "_" + val.name.upper()},              /* ${val.desc} */
  % endfor
  ${proto.prefix.upper()+"_"+field.name.upper()}_MAX_LIMIT
} ${proto.prefix}_${field.name.lower()}_e;
% endif
% endfor

% for field in proto.fields:
% if field.isMask:
/* Flags for ${field.name} field */
typedef enum{
  % for idx,val in enumerate(field.vals):
  ${proto.prefix.upper()+"_"+field.name.upper() + "_" + val.name.upper()} = ${ field.valsFormat % (1 << idx)},    /* ${val.desc} */
  % endfor
  ${proto.prefix.upper()+"_"+field.name.upper()}_MAX_LIMIT  
} ${proto.prefix}_${field.name.lower()}_e;
% endif
% endfor



//Declare extern packet descriptors
% for packet in proto.packets:
extern poly_packet_desc_t* ${packet.globalName};
% endfor


//Declare extern field descriptors
% for field in proto.fields:
extern poly_field_desc_t* ${field.globalName};
% endfor

/*@brief The main type dealt with by the user
 *@note just wraps a poly_packet to prevent mixing them when multiple protocol are in use
 */
typedef struct{
  poly_packet_t mPacket;    //internal packet structure
}${proto.prefix}_packet_t;


/*******************************************************************************
  Service Functions
*******************************************************************************/
/**
*@brief initializes protocol service
*@param ifaces number of interfaces to use
*/
void ${proto.prefix}_service_init(int interfaceCount);

/**
  *@brief processes data in buffers
  */
void ${proto.prefix}_service_process();

/**
  *@brief sends packet over given interface
  *@param metaPacket packet to be sent
  *@param iface index of interface to send on
  */
void ${proto.prefix}_service_register_tx( int iface, poly_tx_callback txCallBack);

/**
  *@brief 'Feeds' bytes to service at given interface for processing
  *@param iface index of interface to send on
  *@param data data to be processed
  *@param number of bytes
  */
void ${proto.prefix}_service_feed(int iface, uint8_t* data, int len);

/**
  *@brief sends packet over given interface
  *@param metaPacket packet to be sent
  *@param iface index of interface to send on
  */
HandlerStatus_e ${proto.prefix}_send( int iface, ${proto.prefix}_packet_t* metaPacket);

/**
  *@brief enables/disables the auto acknowledgement function of the service
  *@param enable true enable auto acks, false disables them
  */
void ${proto.prefix}_auto_ack(bool enable);


/*******************************************************************************
  Meta-Packet Functions
*******************************************************************************/

/**
  *@brief creates a new ${proto.prefix}_packet_t object OWNER IS RESPONSIBLE FOR DESTROYING
  *@param desc ptr to packet descriptor to model packet from
  *@return ptr to new {proto.prefix}_packet_t
  */
${proto.prefix}_packet_t* new_${proto.prefix}_packet(poly_packet_desc_t* desc);


/**
  *@brief recrusively destroys ${proto.prefix}_packet_t and its contents
  *@param metaPacket metapacket to destroy
  */
void ${proto.prefix}_destroy(${proto.prefix}_packet_t* metaPacket);

/**
  *@brief converts packet to json
  *@param packet ptr to packet to convert
  *@param buf buffer to store string
  *@return length of string
  */
#define ${proto.prefix}_print_json(packet,buf) poly_packet_print_json(&packet->mPacket, buf, false)

/**
  *@brief parses packet from a buffer of data
  *@param packet ptr to packet to be built
  *@param buf buffer to parse
  *@return status of parse attempt
  */
#define ${proto.prefix}_parse(packet,buf,len) poly_packet_parse_buffer(&packet->mPacket, buf, len)


/**
  *@brief packs packet into a byte array
  *@param packet ptr to packet to be packed
  *@param buf buffer to store data
  *@return length of packed data
  */
#define ${proto.prefix}_pack(packet, buf) poly_packet_pack(&packet->mPacket, buf)


/*******************************************************************************
  Meta-Packet setters
*******************************************************************************/
% for field in proto.fields:
  %if field.isArray:
void ${proto.prefix}_set${field.name.capitalize()}(${proto.prefix}_packet_t* packet, const ${field.getParamType()} val);
  % else:
void ${proto.prefix}_set${field.name.capitalize()}(${proto.prefix}_packet_t* packet, ${field.getParamType()} val);
  % endif
% endfor

/*******************************************************************************
  Meta-Packet getters
*******************************************************************************/
% for field in proto.fields:
${field.getParamType()} ${proto.prefix}_get${field.name.capitalize()}(${proto.prefix}_packet_t* packet);
% endfor

/*******************************************************************************
  Packet Handlers
*******************************************************************************/
% for packet in proto.packets:
%if packet.hasResponse:
/*@brief Handler for ${packet.name} packets */
HandlerStatus_e ${proto.prefix}_${packet.name.lower()}_handler(${proto.prefix}_packet_t* ${packet.name}, ${proto.prefix}_packet_t* ${packet.response.name});
%else:
/*@brief Handler for ${packet.name} packets */
HandlerStatus_e ${proto.prefix}_${packet.name.lower()}_handler(${proto.prefix}_packet_t* ${packet.name});
%endif

% endfor
/*@brief Catch-All Handler for unhandled packets */
HandlerStatus_e ${proto.prefix}_default_handler(${proto.prefix}_packet_t * packet);
